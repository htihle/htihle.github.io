---
layout: nothing
title: WeirdML Model Landscape
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WeirdML Model Landscape</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            margin: 0;
            padding: 15px;
            background: #f8f9fa;
            color: #333;
        }

        .header {
            position: relative;
            text-align: center;
            margin-bottom: 15px;
        }

        .header h1 {
            margin: 0;
            font-size: 1.4rem;
            color: #2c3e50;
        }

        .header-links {
            position: absolute;
            top: 0;
            left: 0;
            display: flex;
            gap: 12px;
        }

        .header-links a {
            color: #3498db;
            text-decoration: none;
            font-size: 0.85rem;
        }

        .header-links a:hover {
            text-decoration: underline;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: flex-end;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.75rem;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .button-group {
            display: flex;
            gap: 5px;
        }

        .control-btn {
            padding: 6px 12px;
            border: 2px solid #3498db;
            background: white;
            color: #3498db;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background: #ecf6fd;
        }

        .control-btn.active {
            background: #3498db;
            color: white;
        }

        .size-legend {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
            color: #666;
        }

        .size-legend-dot {
            border-radius: 50%;
            background: #ccc;
            display: inline-block;
        }

        .chart-container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 10px;
            overflow: hidden;
        }

        #chart {
            width: 100%;
            height: 70vh;
            min-height: 400px;
        }

        .tooltip {
            position: absolute;
            pointer-events: none;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            font-size: 0.85rem;
            max-width: 300px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-title {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 8px;
            color: #2c3e50;
            border-bottom: 1px solid #eee;
            padding-bottom: 6px;
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
        }

        .tooltip-label {
            color: #666;
        }

        .tooltip-value {
            font-weight: 500;
            color: #333;
        }

        .model-dot {
            cursor: pointer;
            transition: opacity 0.15s ease;
        }

        .model-label {
            font-size: 13px;
            font-weight: 500;
            fill: #333;
            pointer-events: none;
        }

        .axis-label {
            font-size: 13px;
            font-weight: 500;
            fill: #555;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            padding: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            color: #555;
        }

        .legend-icon {
            width: 20px;
            height: 20px;
            object-fit: contain;
        }

        .legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }

        @media (max-width: 1200px), (max-height: 500px) {
            body {
                padding: 8px;
            }

            .header {
                margin-bottom: 8px;
            }

            .header h1 {
                font-size: 1.1rem;
            }

            .header-links {
                position: static;
                justify-content: center;
                margin-top: 6px;
                gap: 10px;
            }

            .header-links a {
                font-size: 0.75rem;
            }

            .controls {
                padding: 8px;
                gap: 8px;
                margin-bottom: 8px;
            }

            .control-group label {
                font-size: 0.65rem;
            }

            .control-btn {
                padding: 5px 10px;
                font-size: 0.75rem;
            }

            .chart-container {
                padding: 5px;
            }

            #chart {
                height: calc(100vh - 170px);
                min-height: 200px;
            }

            .model-label {
                font-size: 10px;
            }

            .legend {
                display: flex !important;
                gap: 6px;
                padding: 4px;
                margin-top: 5px;
            }

            .legend-item {
                font-size: 0.65rem;
                gap: 3px;
            }

            .legend-icon {
                width: 14px;
                height: 14px;
            }

            .legend-dot {
                width: 10px;
                height: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>WeirdML: Model Landscape</h1>
        <div class="header-links">
            <a href="weirdml.html">&larr; Back to WeirdML</a>
            <a href="weirdml_interactive.html">Standard plot</a>
            <a href="weirdml_table.html">Data table</a>
            <a href="data/weirdml_data.csv">CSV</a>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>X-Axis</label>
            <div class="button-group">
                <button class="control-btn active" data-mode="cost">Cost ($0–20)</button>
                <button class="control-btn" data-mode="tokens">Tokens</button>
                <button class="control-btn" data-mode="date">Date</button>
            </div>
        </div>
        <div class="control-group">
            <label>Scale</label>
            <div class="button-group">
                <button class="control-btn scale-btn active" data-scale="log">Log</button>
                <button class="control-btn scale-btn" data-scale="linear">Linear</button>
            </div>
        </div>
        <div class="size-legend">
            <span>Bubble size = output tokens:</span>
            <span class="size-legend-dot" style="width:8px;height:8px;"></span> 1k
            <span class="size-legend-dot" style="width:16px;height:16px;"></span> 10k
            <span class="size-legend-dot" style="width:28px;height:28px;"></span> 30k+
        </div>
    </div>

    <div class="chart-container">
        <svg id="chart"></svg>
    </div>

    <div class="legend" id="legend"></div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        const companyColors = {
            'OpenAI': '#74aa9c',
            'Anthropic': '#d97757',
            'Google': '#4285f4',
            'DeepSeek': '#536dfe',
            'xAI': '#4d4d4d',
            'Meta': '#0668e1',
            'Mistral': '#ff7000',
            'Qwen': '#ff7f00',
            'Moonshot': '#0084ff',
            'ZhipuAI': '#10b981',
            'Gemma': '#2ecc71',
            'Other': '#888888'
        };

        const companyIcons = {
            'OpenAI': { path: 'assets/icons/openai_icon.png', size: 34 },
            'Anthropic': { path: 'assets/icons/claude_logo.png', size: 21 },
            'Google': { path: 'assets/icons/gemini_logo.png', size: 21 },
            'DeepSeek': { path: 'assets/icons/deepseek_whale.png', size: 31 },
            'xAI': { path: 'assets/icons/grok_logo.png', size: 21 },
            'Meta': { path: 'assets/icons/meta_logo.png', size: 26 },
            'Mistral': { path: 'assets/icons/mistral_logo.png', size: 19 },
            'Qwen': { path: 'assets/icons/alibaba_icon.png', size: 30 },
            'Moonshot': { path: 'assets/icons/kimi_logo.png', size: 19 },
            'Gemma': { path: 'assets/icons/gemma-logo.png', size: 35 },
            'ZhipuAI': { path: 'assets/icons/z-ai_logo.png', size: 25 }
        };

        const iconImages = {};
        const iconLoadPromises = Object.entries(companyIcons).map(([company, config]) => {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => { iconImages[company] = img; resolve(); };
                img.onerror = () => resolve();
                img.src = config.path;
            });
        });

        function getCompany(d) {
            const name = d.display_name.toLowerCase();
            if (name.includes('gpt') || name.startsWith('o1') || name.startsWith('o3') || name.startsWith('o4')) return 'OpenAI';
            if (name.includes('claude')) return 'Anthropic';
            if (name.includes('gemini')) return 'Google';
            if (name.includes('gemma')) return 'Gemma';
            if (name.includes('deepseek')) return 'DeepSeek';
            if (name.includes('grok')) return 'xAI';
            if (name.includes('llama')) return 'Meta';
            if (name.includes('mistral') || name.includes('mixtral')) return 'Mistral';
            if (name.includes('qwen')) return 'Qwen';
            if (name.includes('kimi')) return 'Moonshot';
            if (name.includes('glm')) return 'ZhipuAI';
            return 'Other';
        }

        function getColor(d) {
            return companyColors[getCompany(d)] || '#888888';
        }

        // Models to always label
        const alwaysHighlight = new Set([
            'claude-3.6-sonnet',
            'claude-3-opus',
            'gpt-4-0613',
            'deepseek-r1',
            'o3 (high)',
            'gemini-2.5-pro (thinking 16k)'
        ]);

        function getParetoFrontier(data, getX, getY) {
            const sorted = [...data].sort((a, b) => getX(a) - getX(b));
            const frontier = [];
            let maxY = -Infinity;
            for (const d of sorted) {
                const y = getY(d);
                if (y > maxY) {
                    frontier.push(d);
                    maxY = y;
                }
            }
            return new Set(frontier.map(d => d.display_name));
        }

        let data = [];
        let currentMode = 'cost';
        let currentScale = 'log';

        const margin = { top: 30, right: 40, bottom: 60, left: 65 };
        const svg = d3.select('#chart');
        const tooltip = d3.select('#tooltip');

        // Bubble size scale: tokens → radius
        const sizeScale = d3.scaleSqrt()
            .domain([0, 35000])
            .range([3, 22]);

        function getXValue(d) {
            switch (currentMode) {
                case 'cost': return +d.cost_per_run_usd;
                case 'tokens': return +d.mean_total_output_tokens;
                case 'date': return new Date(d.release_date);
            }
        }

        function getXLabel() {
            switch (currentMode) {
                case 'cost': return 'Average Cost per Run (USD)';
                case 'tokens': return 'Average Total Output Tokens';
                case 'date': return 'Release Date';
            }
        }

        function updateChart() {
            const container = document.getElementById('chart').parentElement;
            const width = container.clientWidth - 20;

            const isMobile = window.innerWidth <= 1200 || window.innerHeight <= 500;
            const height = isMobile
                ? Math.max(200, window.innerHeight - 170)
                : Math.max(400, window.innerHeight * 0.7);

            svg.attr('width', width).attr('height', height);
            svg.selectAll('*').remove();

            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Filter valid data — cap cost at $20 in cost mode
            const validData = data.filter(d => {
                const x = getXValue(d);
                const y = +d.avg_acc;
                if (currentMode === 'date') {
                    return x instanceof Date && !isNaN(x) && y > 0;
                }
                if (currentMode === 'cost') {
                    return x > 0 && x <= 20 && y > 0;
                }
                return x > 0 && y > 0;
            });

            // Create scales
            let xScale;
            if (currentMode === 'date') {
                xScale = d3.scaleTime()
                    .domain(d3.extent(validData, d => getXValue(d)))
                    .range([0, innerWidth])
                    .nice();
            } else if (currentScale === 'log') {
                xScale = d3.scaleLog()
                    .domain(d3.extent(validData, d => getXValue(d)))
                    .range([0, innerWidth])
                    .nice();
            } else {
                const maxX = currentMode === 'cost' ? 20 : d3.max(validData, d => getXValue(d)) * 1.05;
                xScale = d3.scaleLinear()
                    .domain([0, maxX])
                    .range([0, innerWidth])
                    .nice();
            }

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(validData, d => +d.avg_acc) * 1.05])
                .range([innerHeight, 0])
                .nice();

            const frontier = getParetoFrontier(validData, d => getXValue(d), d => +d.avg_acc);

            // Add axes
            const xAxis = currentMode === 'date'
                ? d3.axisBottom(xScale).ticks(6)
                : currentScale === 'log'
                    ? d3.axisBottom(xScale).ticks(6, '~s')
                    : d3.axisBottom(xScale).ticks(6);

            g.append('g')
                .attr('transform', `translate(0,${innerHeight})`)
                .call(xAxis)
                .selectAll('text')
                .style('font-size', '12px');

            const xAxisTop = currentMode === 'date'
                ? d3.axisTop(xScale).ticks(6)
                : currentScale === 'log'
                    ? d3.axisTop(xScale).ticks(6, '~s')
                    : d3.axisTop(xScale).ticks(6);

            g.append('g')
                .call(xAxisTop)
                .selectAll('text')
                .style('font-size', '12px');

            g.append('g')
                .call(d3.axisLeft(yScale).tickFormat(d3.format('.0%')))
                .selectAll('text')
                .style('font-size', '12px');

            g.append('text')
                .attr('class', 'axis-label')
                .attr('x', innerWidth / 2)
                .attr('y', innerHeight + 45)
                .attr('text-anchor', 'middle')
                .text(getXLabel());

            g.append('text')
                .attr('class', 'axis-label')
                .attr('transform', 'rotate(-90)')
                .attr('x', -innerHeight / 2)
                .attr('y', -50)
                .attr('text-anchor', 'middle')
                .text('Average Accuracy Across 17 Tasks');

            g.append('g')
                .attr('class', 'grid')
                .attr('opacity', 0.1)
                .call(d3.axisLeft(yScale)
                    .tickSize(-innerWidth)
                    .tickFormat(''));

            // Build dot data
            const dotData = validData.map(d => {
                const company = getCompany(d);
                const isFrontier = frontier.has(d.display_name);
                const tokens = +d.mean_total_output_tokens;
                const r = sizeScale(tokens);
                return {
                    d: d,
                    company: company,
                    isFrontier: isFrontier,
                    cx: xScale(getXValue(d)),
                    cy: yScale(+d.avg_acc),
                    r: r,
                    tokens: tokens
                };
            });

            // Sort: frontier on top
            dotData.sort((a, b) => (a.isFrontier ? 1 : 0) - (b.isFrontier ? 1 : 0));

            let hoveredDot = null;

            // Draw Pareto frontier line
            const frontierDots = dotData.filter(d => d.isFrontier);
            frontierDots.sort((a, b) => a.cx - b.cx);
            if (frontierDots.length > 1) {
                const lineGen = d3.line()
                    .x(d => d.cx)
                    .y(d => d.cy)
                    .curve(d3.curveMonotoneX);
                g.append('path')
                    .datum(frontierDots)
                    .attr('d', lineGen)
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 1.5)
                    .attr('stroke-dasharray', '6,4')
                    .attr('opacity', 0.5);
            }

            // Draw bubbles
            dotData.forEach(item => {
                const { d, company, isFrontier, cx, cy, r } = item;
                const color = companyColors[company] || '#888888';

                item.element = g.append('circle')
                    .attr('class', 'model-dot')
                    .attr('cx', cx)
                    .attr('cy', cy)
                    .attr('r', r)
                    .attr('fill', color)
                    .attr('stroke', '#fff')
                    .attr('stroke-width', isFrontier ? 2 : 1)
                    .attr('opacity', isFrontier ? 0.9 : 0.6)
                    .datum(d)
                    .style('pointer-events', 'none');
            });

            // Invisible overlay for hover
            g.append('rect')
                .attr('width', innerWidth)
                .attr('height', innerHeight)
                .attr('fill', 'transparent')
                .style('cursor', 'default')
                .on('mousemove touchmove', function(event) {
                    const [mx, my] = d3.pointer(event, this);

                    let closest = null;
                    let minDist = Infinity;
                    const maxDist = 50;

                    dotData.forEach(item => {
                        const dist = Math.sqrt((mx - item.cx) ** 2 + (my - item.cy) ** 2);
                        if (dist < minDist && dist < maxDist) {
                            minDist = dist;
                            closest = item;
                        }
                    });

                    if (closest !== hoveredDot) {
                        if (hoveredDot) {
                            hoveredDot.element
                                .attr('r', hoveredDot.r)
                                .attr('stroke-width', hoveredDot.isFrontier ? 2 : 1);
                        }
                        if (closest) {
                            closest.element
                                .attr('r', closest.r * 1.3)
                                .attr('stroke-width', 2.5);
                            showTooltip(event, closest.d);
                        } else {
                            hideTooltip();
                        }
                        hoveredDot = closest;
                    } else if (closest) {
                        moveTooltip(event);
                    }
                })
                .on('mouseleave touchend', function() {
                    if (hoveredDot) {
                        hoveredDot.element
                            .attr('r', hoveredDot.r)
                            .attr('stroke-width', hoveredDot.isFrontier ? 2 : 1);
                        hoveredDot = null;
                        hideTooltip();
                    }
                });

            // Labels for frontier models (LEFT side)
            addLabelsWithBackground(
                validData.filter(d => frontier.has(d.display_name)),
                'label-frontier', 'end',
                d => xScale(getXValue(d)) - sizeScale(+d.mean_total_output_tokens) - 6,
                g, xScale, yScale, innerWidth, innerHeight, 'left'
            );

            // Labels for always-highlighted models (RIGHT side)
            addLabelsWithBackground(
                validData.filter(d => alwaysHighlight.has(d.display_name) && !frontier.has(d.display_name)),
                'label-highlight', 'start',
                d => xScale(getXValue(d)) + sizeScale(+d.mean_total_output_tokens) + 6,
                g, xScale, yScale, innerWidth, innerHeight, 'right'
            );
        }

        function addLabelsWithBackground(data, className, anchor, getX, g, xScale, yScale, innerWidth, innerHeight, side) {
            const labelGroups = g.selectAll('.' + className)
                .data(data)
                .enter()
                .append('g')
                .attr('class', className);

            labelGroups.append('rect')
                .attr('class', 'label-bg')
                .attr('fill', 'white')
                .attr('opacity', 0.7)
                .attr('rx', 2)
                .attr('ry', 2);

            labelGroups.append('text')
                .attr('class', 'model-label')
                .attr('text-anchor', anchor)
                .attr('x', d => getX(d))
                .attr('y', d => yScale(+d.avg_acc) + 4)
                .text(d => d.display_name);

            // Adjust label positions
            const labelNodes = labelGroups.select('text').nodes();
            const positions = [];
            labelNodes.forEach((node) => {
                const d = d3.select(node).datum();
                const bbox = node.getBBox();
                const r = sizeScale(+d.mean_total_output_tokens);
                const baseX = side === 'left'
                    ? xScale(getXValue(d)) - r - 6
                    : xScale(getXValue(d)) + r + 6;
                positions.push({
                    node: node,
                    x: baseX,
                    y: yScale(+d.avg_acc) + 4,
                    width: bbox.width,
                    height: bbox.height
                });
            });

            positions.sort((a, b) => a.y - b.y);
            for (let i = 1; i < positions.length; i++) {
                const prev = positions[i - 1];
                const curr = positions[i];
                if (Math.abs(curr.x - prev.x) < 120) {
                    const minGap = 16;
                    if (curr.y - prev.y < minGap) {
                        curr.y = prev.y + minGap;
                    }
                }
            }

            positions.forEach(p => {
                if (side === 'left') {
                    p.x = Math.max(p.width + 5, p.x);
                } else {
                    p.x = Math.min(innerWidth - p.width - 5, p.x);
                }
                p.y = Math.max(15, Math.min(p.y, innerHeight - 5));
                d3.select(p.node).attr('x', p.x).attr('y', p.y);
            });

            labelGroups.each(function() {
                const group = d3.select(this);
                const text = group.select('text');
                const bbox = text.node().getBBox();
                group.select('rect')
                    .attr('x', bbox.x - 2)
                    .attr('y', bbox.y - 1)
                    .attr('width', bbox.width + 4)
                    .attr('height', bbox.height + 2);
            });
        }

        function showTooltip(event, d) {
            const company = getCompany(d);
            let html = `<div class="tooltip-title">${d.display_name}</div>`;
            html += `<div class="tooltip-row"><span class="tooltip-label">Company:</span><span class="tooltip-value">${company}</span></div>`;
            html += `<div class="tooltip-row"><span class="tooltip-label">Accuracy:</span><span class="tooltip-value">${(+d.avg_acc * 100).toFixed(1)}%</span></div>`;
            html += `<div class="tooltip-row"><span class="tooltip-label">Cost:</span><span class="tooltip-value">$${(+d.cost_per_run_usd).toFixed(4)}</span></div>`;
            html += `<div class="tooltip-row"><span class="tooltip-label">Tokens:</span><span class="tooltip-value">${Math.round(+d.mean_total_output_tokens).toLocaleString()}</span></div>`;
            html += `<div class="tooltip-row"><span class="tooltip-label">Release:</span><span class="tooltip-value">${d.release_date}</span></div>`;
            html += `<div class="tooltip-row"><span class="tooltip-label">Code Lines (median):</span><span class="tooltip-value">${Math.round(+d.code_len_p50)}</span></div>`;
            html += `<div class="tooltip-row"><span class="tooltip-label">Exec Time (median):</span><span class="tooltip-value">${(+d.exec_time_median_s).toFixed(1)}s</span></div>`;
            tooltip.html(html).classed('visible', true);
            moveTooltip(event);
        }

        function moveTooltip(event) {
            const tooltipNode = tooltip.node();
            const tooltipRect = tooltipNode.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const clientX = event.touches ? event.touches[0].pageX : event.pageX;
            const clientY = event.touches ? event.touches[0].pageY : event.pageY;
            let x = clientX + 15;
            let y = clientY - 10;
            if (x + tooltipRect.width > viewportWidth - 10) x = clientX - tooltipRect.width - 15;
            if (y + tooltipRect.height > viewportHeight - 10) y = clientY - tooltipRect.height - 10;
            if (y < 10) y = 10;
            tooltip.style('left', x + 'px').style('top', y + 'px');
        }

        function hideTooltip() {
            tooltip.classed('visible', false);
        }

        function updateLegend() {
            const legend = document.getElementById('legend');
            const companies = ['OpenAI', 'Anthropic', 'Google', 'DeepSeek', 'xAI', 'Meta', 'Mistral', 'Qwen', 'Moonshot', 'ZhipuAI'];
            legend.innerHTML = companies.map(company => {
                const iconConfig = companyIcons[company];
                if (iconImages[company] && iconConfig) {
                    return `<div class="legend-item"><img class="legend-icon" src="${iconConfig.path}" alt="${company}"><span>${company}</span></div>`;
                } else {
                    return `<div class="legend-item"><div class="legend-dot" style="background: ${companyColors[company]}; border: 1px solid #ccc;"></div><span>${company}</span></div>`;
                }
            }).join('');
        }

        Promise.all(iconLoadPromises).then(() => {
            d3.csv('data/weirdml_data.csv?' + Date.now()).then(csvData => {
                data = csvData;
                updateChart();
                updateLegend();
            });
        });

        document.querySelectorAll('.control-btn[data-mode]').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.control-btn[data-mode]').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentMode = this.dataset.mode;
                const scaleBtns = document.querySelectorAll('.scale-btn');
                if (currentMode === 'date') {
                    scaleBtns.forEach(b => { b.disabled = true; b.style.opacity = 0.5; });
                } else {
                    scaleBtns.forEach(b => { b.disabled = false; b.style.opacity = 1; });
                }
                updateChart();
            });
        });

        document.querySelectorAll('.scale-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                if (currentMode === 'date') return;
                document.querySelectorAll('.scale-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentScale = this.dataset.scale;
                updateChart();
            });
        });

        window.addEventListener('resize', debounce(updateChart, 250));

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => { clearTimeout(timeout); func(...args); };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
    </script>
</body>
</html>
